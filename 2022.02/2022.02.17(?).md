# 2022. 02. 17 Today I Learned
## JavaScript 강의 들은거 정리하기
 자바스크립트 강의를 시작했습니다. 오늘 하루 강의 들은 내용을 바탕으로 최대한 자세히 정리를 해봤는데,     
 아무래도 저는 파이썬이라는 프로그래밍 언어를 한번 배운 전적이 있어서 그런가 확실히 이해가 한번에 되는 내용들이 많네요. 언어를 하나정도 미리 배워보는것도 도움이 되는 것 같습니다.     
 나중엔 이런 내용들을 정리해서 네이버 블로그에도 올려보도록 하겠습니다.
***
## JavaScript
- 변수 선언 → let (변수명) = (값);
    - 변수 선언 규칙
        - 기호 사용할 수 없음
        - 언더스코어(_) 와 달러($)는 변수명에 사용해도 문제가 되지 않음.
        - 변수는 항상 문자로 시작해야한다. 숫자로 시작할 수 없다.
        - var로도 변수를 선언할 수 있음. 다만 var는 변수를 재선언해도 오류가 나지 않아 문제를 일으킬 수 있지만, let은 변수를 한번 선언하면 다시 선언할 수 없기때문에 중복선언의 문제를 피할 수 있다.

- 상수 선언 → const (변수명) = (값);
    - 상수 선언 규칙
        - 상수는 선언하고 나면 읽기 전용임. 쓸 수 없음 (수정할 수 없음)
        

---

- 자료값?
    1. Primitive (원시 타입) : Number, String, Boolean, Undefined, Null
    2.  Non - Primitive (비원시 타입) : Object, Array, Function
    
    - 파이썬 강의를 들으면서 한번씩 다뤄봤던 내용들이라 쉽게 와닿는다.
    - 원시 타입
        - 내장형 타입, 기본형 타입이라고도 함. 하나에 한 번의 고정된 값만 가질 수 있음. 하나의 고정된 저장 공간 활용.
        - 숫자형 타입에는 무한대, -무한대, NaN 이라는 타입도 들어가있다.
            - NaN?
                
                수학적인 연산의 실패값.
                
    - 자바스크립트에서 변수에 아무런 값도 넣어주지 않으면 undefined 라는 값이 나온다. null 이라는 값을 직접 출력시키려면 우리가 의도적으로 변수 안에 null 이라는 값을 넣어주어야 한다.
    
    - 자바스크립트는 12 * “2” 를 실행해도 24라는 값을 출력함. 사칙연산을 수행할 때 자료형이 다르더라도 적절하게 형 변환(캐스팅)을 시켜서 연산을 지속한다는 것. 묵시적 형변환 이라고도 함.
    - 그러나 12 + “2” 를 실행하면 14가 아닌 122가 나옴. 24는 int로 나왔지만 122는 String으로 출력된다. 앞의 12를 string으로 묵시적 형변환을 시켜 서로를 갖다붙였기 때문.
        
        아주 지 맘대로구나..!
        
        - 14라는 int값을 출력하고 싶다면 “2” 앞에 parseInt(”2”) 라고 해야한다.
            - 이렇게 형 변환을 하는 것을 명시적 형변환 이라고한다.
    
    ---
    

- 자바스크립트의 변수 집어넣는 법 : ${ 변수명 }
    - 달러와 중괄호....
    

---

- 연산자
    1. 대입연산자
        
        ex) let a = 1;
        
    2. 사칙연산자
        
        a / b → 몫을 구함
        
        a % b → 나머지를 구함
        
    3. 연결연산자
        
        문자열로 사칙연산 기호를 사용하면 그냥 뒤에다 갖다붙임.
        
    4. 복합연산자
        
        let a = 5;
        
        a += 10;
        
        console.log(a); → 15
        
        사칙연산기호 모두 사용 가능함.
        
    5. 증감연산자
        1. 숫자형에만 사용할 수 있음.
        2. 산술연산자를 두번 이어서 사용하면 됨.
            
            let a = 10;
            
            a ++;
            
            console.log(a); → 11
            
            ---
            
            let a = 10;
            
            console.log(++a) → 11
            
        3. 뒤에 ++을 붙일 경우 그 라인이 끝나고 나서 증감연산자가 적용됨. 후위연산이 적용.
        4. 앞에 ++을 붙일 경우 그 라인부터 증감연산자가 적용됨. 전위연산이 적용.
        
    6. 논리연산자
        1. ! → not 연산자.
        2. && → and 연산자. 
        3. || → or 연산자. 
    7. 비교연산자
        
        1 == “1” → True. 자바스크립트에서는 값만 비교한다. 자료형을 고려하지 않음.
        
        1 === “1” → False. 자료형까지 고려해야 하는 비교연산자.
        
        1 ! = “1” → False.
        
        1 ! == “1” → True.
        
        1 > 2 → False.
        
        1 > = 2 → False.
        
        typeof (변수명) → 변수의 자료형(타입) 출력.
        
        일반적으로 타입까지 비교하는게 훨씬 안전하다.
        
    8. null 병합 연산자
        
        a에 값이 있으면 a를 그대로 대입하고, a에 값이 없으면 10을 대입해라
        
        let a;
        
        a = a ?? 10
        
        console.log(a); → 10
        

---

- 조건문
    
    let a = 3;
    
    if( a > = 5 ) {
    
    console.log(”5 이상입니다.”);
    
    } else {
    
    console.log(”5 이하입니다.”);
    
    }
    
    중간에 조건을 추가하려면 else if (조건) 를 사용하면 된다.
    
    let country = “ko”
    
    switch(country){
    
    case “ko”:
    
    console.log(”Korea”);
    
    break;
    
    case “cn”
    
    console.log(”China”);
    
    break;
    
    default :
    
    console.log(”미분류”);
    
    break;
    
    }
    

---

- 함수
    1. 함수선언식
        
        function (함수명)(){
        
        함수 내용;
        
        }
        
    2. 함수 호출
        
        (함수명)();
        
    3. 매개변수
        
        function test(a, b){
        
        let result = a * b;
        
        console.log(result);
        
        }
        
        test(100, 200);
        
        → 여기서 a, b가 매개변수를 전달받는 역할을 함
        
        console.log(result); 대신 return result; 를 사용해도 됨.
        
    4. 함수표현식
        
              let hello = function () {
        
        return “Hello guys”;
        
        }
        
        const helloText = hello();
        
        console.log(helloText); → Hello guys
        
    5. 함수표현식 vs 함수선언식
        1. 자바스크립트에는 호이스팅(Hoisting)이라는것이 있음.
            1. 함수 선언식으로 만들어놓은 함수는 위치와 상관없이 실행과 동시에 함수가 실행되어 return값을 대기시키고 있다.
            2. 함수표현식으로 만들어놓은 함수는 호이스팅이 이루어지지 않아 함수 생성과 함수 실행의 순서가 중요하다.
            
    6. 화살표함수
        1. let hello = () = > {
            
            return (리턴값);
            
            }
            
        2. 화살표함수 또한 호이스팅의 대상이 아니므로 순서에 유의해야 한다.
        
    7. 콜백함수
        
        ```jsx
        function checkMood(mood, goodCallback, badCallback) {
        	if ( mood === "good") {
        		goodCallback();
        	} else {
        		badCallback();
        	}
        }
        function cry() {
        	console.log("cry");
        }
        function sing() {
        	console.log("sing");
        }
        
        checkMood("good",sing,cry);
        ```
        
        함수로 선언해놓은 sing, cry를 goodCallback, badCallback이라는 함수의 매개변수로 사용하는 것. 함수표현식의 원리를 이용한 것이다.
        

---

- 객체
    1. 객체 생성방법
        
        let person = new Object(); → 생성자 방식
        
        let person = {}; → 객체 리터럴 방식
        
    2. 객체의 값 저장 방법
        
        let person = {
        
        key: “value”,  → key, value 한쌍으로 저장되는 값을 프로퍼티(속성). 객체 프로퍼티 라고함.
        
        }
        
        1. value 부분에는 모든 자료형을 수용 가능함.
            1. 프로퍼티 안에 함수도 수용 가능한데, 객체 안에 value로서 존재하는 함수를 매서드라고 함. 이 객체를 다루는 방법이라는 뜻에서 메서드(method == 방법)
            2. 함수가 아닌 프로퍼티들은 멤버(member)라고 부른다.
                1. 메서드 안에서 멤버를 불러올 수 있음.
                    
                    key : function () {
                    
                    console.log( `hi, ${this.(value)}`);
                    
                    점표기법, 괄호표기법 모두 사용 가능함. 객체 안에서 객체 스스로를 칭할때에는 객체 이름을 쓰지 않고 this라는 표현을 사용함.
                    
        2. key 부분에는 문자열이 와야하는데, 따옴표를 따로 사용하지 않음.
        
    3. 여러 프로퍼티들 중에서 특정 key를 가져오는법
        
        console.log((객체명).key); → 점 표기법. key와 매칭되는 value를 출력해줌.
        
        console.log((객체명)[”key”]); → 괄호 표기법. key에 반드시 따옴표를 붙여서 사용해야 함.
        
    4. 객체에 프로퍼티를 객체 밖에서 추가하는 방법
        
        (객체명).(추가할key이름) = (value); 
        
        (객체명)[”추가할key이름”) = (value);
        
        - 이와같은 방법으로 프로퍼티를 추가할 수도 있지만 존재하는 프로퍼티를 수정하는 데에도 사용할 수 있는 방법이다.
        - 객체를 생성할 때 let이 아닌 const로 생성해도 객체 자체가 가지고 있는 속성을 수정하는 것이지, 객체 자체를 수정하는 것은 아니기때문에 수정 방법이 잘 먹힌다.
            - 그렇다면 const로 생성된 상수 객체를 수정하는 행위는?
                - (객체명) = {
                    
                    key = value
                    
                    }
                    
                - 이렇게 상수로 선언한 객체 자체에 다시 대입을 하는게 아닌이상 에러가 발생하진 않음.
                
    5. 객체의 속성(프로퍼티) 삭제하는 방법
        
        delete (객체명).(프로퍼티명);
        
        → 점표기법이던 괄호표기법이던 상관은 없음.
        
        - 그러나 위와 같은 방식으로 프로퍼티를 삭제하면 프로퍼티가 사라지긴 해도 메모리는 계속 할당되어 있음. 즉, 메모리는 계속 잡아먹고있단 소리.
        - 이런 문제를 해결하기 위해 다른 방법을 사용하는 것을 추천하는데,
        
        (객체명).(프로퍼티명) = null;
        
        - 이렇게 프로퍼티를 삭제하면 메모리도 지울 수 있음.
        
    6. 객체 안에 특정 프로퍼티가 존재하는지 확인하는 방법.
        
        (key) in (객체명);
        

---

- 배열
    1. 배열 생성 방법
        
        let arr = new Array();
        
        let arr = []; → 배열 리터럴 방식
        
        → 배열은 대괄호, 객체는 중괄호
        
    2. 배열은 밸류(value)가 위치한 순서(인덱스)를 key라고 생각하면 된다.
        
        arr[0] → 0번째
        
    3. 배열 다루기
        - arr.push(6); → 맨 마지막 순서에 6을 삽입함.
        - arr.length; → 배열의 길이 구해줌