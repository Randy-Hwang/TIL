# 2022. 05. 29 Today I Learned

## Clean Code Javascript

리액트로 얼른 넘어가고싶지만, 리액트도 결국 간편한 기능이 추가된 자바스크립트와 다를 바가 없기 때문에 자바스크립트 강의를 하나 더 듣기로 했습니다. 리액트 입문 강의는 들었으나, 리액트와 자바스크립트 강의를 번갈아가며 열심히 듣는게 더 도움이 되지않을까 싶습니다. 겹치는 부분도 많기때문에 이거하면 저거까먹고, 저거하면 이거까먹고 할 일도 딱히 없고, 복습도 여러번 할 수 있고 말입니다.

> Var는 지양하고, let과 const 를 사용하자

var는 함수 스코프, let과 const는 블록 스코프를 가집니다. 여기에 더해 TDZ, Temporal Dead Zone 이라는 속성까지 가질 수가 있습니다. 블록 스코프와 TDZ를 적용한다면 굉장히 안전한 코드를 작성할 수 있습니다.

```js
var name = "name";
var name = "name2";

console.log(name); // name2
```

- 변수 명은 같지만 값은 다릅니다. 그럼에도 재할당을 할 수가 있고, 오류는 발생하지 않습니다.

```js
let name = "name";
let name = "name2";

// Syntaxerror = Identifier 'name' has already been declared.
```

name이라는 변수가 이미 선언되었기 때문에 다시 선언할 수 없다는 에러가 발생합니다. var에서는 볼 수 없었던 에러입니다.

- 여기서 let과 const가 다른점은, const는 let과 다르게 재할당이 불가하다는 점입니다.

다만 강의를 듣다 보니 강사님께서 TDZ에 대해 설명을 안해주시네요. Temporal Dead Zone이 무엇일까요?

```js
console.log(name); // undefined
var name = "duckgu";

console.log(height); // ReferenceError = Cannot access 'height' before initialization
const height = "185";
```

TDZ의 예시로 이런 코드를 받게 되었습니다.

- 변수는 크게 세 가지 라이프사이클을 가집니다. 선언, 초기화, 할당.

- var 변수는 선언과 초기화가 동시에 이루어집니다. 그래서 변수 선언보다 콘솔로그를 먼저 실행하였을 때 undefined가 나오게 되었던 것입니다.

- 반면 let 변수는 선언과 초기화가 분리되어 그 사이에 TDZ가 생성됩니다. const는 선언과 초기화가 동시에 진행되지만 선언 이전에 TDZ가 생성됩니다. 그럼 TDZ가 생성되는게 왜 중요한데?

  - TDZ의 역할은 선언 전에 변수를 사용하여 발생하는 에러를 줄여주는 역할을 한다고 합니다.

  - 하긴, 선언도 안해놓고 사용하게되면 코드를 짠 사람이면 몰라도 코드를 위에서부터 읽어내려가는 사람 입장에서는 갑자기 선언도 안된 변수가 사용되어 많이 당황스러울 것 같습니다.

---

TDZ를 배웠으니 그 다음, 스코프에도 차이가 있습니다.

- var의 경우 함수 스코프를 가지고 있습니다. 전역변수는 웬만하면 사용하지 말라는 소리를 많이 합니다.

```js
var global = "전역변수";

if (global === "전역변수") {
  var global = "지역변수";
  console.log(global); // 지역변수
}
console.log(global); // 지역변수
```

이렇듯 if 안에서 변수를 변경 / 재할당하더라도 함수 밖까지 적용이 되는 모습입니다.

- var는 함수단위 스코프를 가지기때문에 발생하는 문제입니다. if문은 함수가 아닙니다. 따라서 이런 문제가 발생할 수 있다는 위험을 지속적으로 가지고있는거죠.

- 그러나 let은 블록 단위 스코프를 가지고있기 때문에 if문 안에서도 지역과 전역을 구분하게 됩니다.

```js
let global = "전역변수";

if (global === "전역변수") {
  let global = "지역변수";
  console.log(global); // 지역변수
}
console.log(global); // 전역변수
```

```js
let global = "전역변수";

{
  let global = "지역변수";
  console.log(global); // 지역변수
}

console.log(global); // 전역변수
```

이렇게 어떠한 동작이 없더라도 블록으로 이루어져있다면 블록 단위 스코프를 가진 let 변수는 지역과 전역을 구분합니다.

- 다만 여기서 지역과 전역이라는 단어가 대충 어떤 의미인진 알 것 같은데, 정확히 어떤 의미를 가진 용어인지 궁금합니다.

- 먼저 지역 변수는, 우리가 위의 예제 코드에서 봤던 것 처럼 블록 안에서만 유효한 변수를 뜻합니다. 블록 안에서 생성되고, 블록 안에서만 사용되어서 블록 밖에서는 사용할 수 없습니다.

```js
{
  let local = "wldur";
  console.log(local); // wldur
}

console.log(local); // ReferenceError : local is not defined
```

- 반대로 전역변수는 말 그대로 모든 영역에서 영향력을 발휘하는 변수입니다. 말로만 들으면 "그냥 한번 선언해놓으면 이 파일 안에서 계속 써먹을 수 있는데 편한거 아닌가?" 싶은 생각이 들 수도 있습니다.

  - 지역변수는 블록, 즉 함수 안에서만 유효하기 때문에, 함수의 생명주기와 동일합니다. 함수가 끝나면 그 함수에서 사용되었던 변수도 같이 생명을 다하는거죠.

- 그렇다면 전역변수를 사용하게 되면 어떤 문제가 발생하게 되느냐, 코드를 적게 짜면 그나마 괜찮은데, 길게 작성하면서부터 문제가 발생하게 됩니다.

  - 전역변수는 코드의 어디서든 참조할 수 있고 변경할 수 있습니다. 코드를 읽는 사람 입장에서 이 전역변수를 계속 신경쓰고있어야 하니 일단 가독성 측면에서 좋지 않습니다. 지역변수는 그 함수 내에서 사용될 때만 변수를 기억해뒀다가 함수가 끝나면 그 변수도 같이 잊어버리면 되는거거든요.

  - 또한, 전역변수로 `name`이라는 변수가 할당되어 있는데, 블록 안에서 `name`이라는 변수가 다시금 선언된다면 예상치 못한 문제가 발생할 수 있습니다.

  - 이러한 이유들 때문에, 스코프는 좁으면 좁을수록 좋다는 말이 많습니다.

  - 안전한 코드라는 관점에서 전역변수보다는 지역변수가 더 좋다는 관점이 있습니다.

