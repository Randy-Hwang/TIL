# 2022. 03. 06 Today I Learned

## Modern JavaScript Deep Dive

## 4장 : 변수

---

- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
  <br></br>

  - 메모리 주소에 직접 접근하는 것은 매우 위험한 방식이기 때문! 또한 코드를 실행할 때 마다 메모리 주소값이 바뀌기 때문에 사용했던 값을 다시 사용한다고 메모리 주소를 사용하는 것은 바람직하지 않다.

    - 따라서 `변수`를 사용하여 값을 저장한다!

### 1. 변수란?

- 하나의 값을 저장하기 위한 매커니즘.

```js
var result = 10 + 20;
```

- 10과 20은 임의의 메모리값에 저장되고, 30 이라는 결과값 또한 메모리 공간을 하나 차지하게 된다. 이 30이라는 결과의 메모리주소는 `result` 라는 메모리 주소의 위치를 가리키는 일종의 식별자이다.

- 즉, `result`를 치면 30이라는 값이 저장되어있는 메모리 주소를 찾아내는 것.

- 이처럼 변수에 값을 저장하는 것을 할당, 저장된 값을 읽는 것을 참조 라고한다.

- 이러한 변수의 이름을 식별자 라고도 한다.

  - 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

---

### 2. 변수 선언 variable declaration

- 말 그대로 변수를 생성하는 것.

  - 조금 더 자세히 말하면, 값을 저장하기 위한 메모리 주소를 확보하고 -> 변수 이름과, 확보된 메모리 공간의 주소를 연결하여 -> 값을 저장할 수 있게 준비하는 것

- 변수 선언에 사용되는 키워드

  - `var` `let` `const`

  ```js
  var score;
  ```

  - 변수를 선언만 하고 값을 할당하지 않을 경우 자바스크립트는 `undefined` 라는 값을 할당하여 초기화한다. 자바스크립트에서 제공하는 원시 타입이다.

  - 자바스크립트 엔진은 선언 단계와 초기화 단계로 나뉜다.

    - 선언 단계 : 변수 이름을 등록하여 자바스크립트 엔진에게 변수의 존재를 알림

    - 초기화 단계 : 메모리 공간을 확보하고 암묵적으로 `undefined`를 저장함.

      - 일반적으로 초기화(initialization)란 변수가 선언된 이후, 최초로 값을 할당하는 것을 말한다.

      - 이런 초기화 단계를 거치지 않으면 확보한 메모리 공간에 이전 어플리케이션에서 사용하던 값이 남아있을 수 있는데, 이 값을 쓰레기 값 (garbage value)이라고 한다.

      - 자바스크립트의 `var` 키워드는 암묵적으로 `undefined`를 사용해 초기화를 수행하므로 이러한 위험으로부터 안전하다.

---

### 3. 변수 호이스팅 variable hoisting

```js
console.log(score); // -> undefined
var score; // 변수 선언문
```

- 변수 선언문보다 변수를 참조하는 코드가 먼저 있다. 그런데에도 참조 에러 (ReferenceError) 가 발생하지 않고 `undefined`가 출력된다.

- 이는 변수 호이스팅 때문인데, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다.

- 변수 선언 뿐만아니라 `var` `let` `class` `function` `const` 등등 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스)는 호이스팅된다.

---

### 4. 값의 할당

```js
var score;
score = 80;

/////////////

var score = 80;
```

- 변수선언문과 그 할당은 두 문장으로 해도, 한 문장으로 해도 정확히 동일하게 동작한다.

  - 한 줄로 작성해도 자바스크립트는 두 줄로 작성한 것 처럼 나누어서 작동한다.

- 그러나 고려해야 할 사항은, "변수선언"은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 실행(호이스팅)되지만, 값의 할당은 소스코드가 한 줄씩 실행되는 런타임에 실행된다.

```js
console.log(score); // undefined
var score = 80;
console.log(score); // 80
```

- 변수 선언문과 값의 할당보다 앞에서 변수를 참조하였으나 호이스팅때문에 ReferenceError는 발생하지 않고 `undefined`가 출력된다. 그러나 값의 할당은 런타임에서 실행되기 때문에 80이라는 값은 2번째 줄이 지나고 나서야 정상적으로 작동한다.

> QUIZ

```js
console.log(score); // undefined
score = 80;
var score;
console.log(score); // ??
```

> 코드가 이렇게 있을 때, 두 번째 참조의 결과는?

> ANSWER
>
> > 80이 출력된다. 우선 호이스팅으로 인해 `score`라는 변수는 선언되었다. 따라서 첫 번째 `score` 참조에서는 `undefined`가 출력된 것.
> >
> > > 값의 할당 코드가 변수의 선언 코드보다 위에있다. 순간 어떻게 작동하는지 당황스러웠으나, 호이스팅으로 인해 `score`라는 변수는 이미 선언되어있으므로, 정상적으로 80이라는 값이 할당된다. 그러므로 두 번째 참조의 결과는 80이 출력된다.

---

### 5. 값의 재할당

```js
var score = 80;
score = 90;
```

- 이 경우 `score`의 값은 90이 된다. 할당된 값에 다시 변수를 할당하는 것을 재할당이라고 한다.

- `score`가 처음 선언되었을 때의 원시 타입인 `undefined`, 처음 값이 할당되었을 때의 값인 `80`은 더이상 사용되지 않는다.

  - 이들은 가비지 콜렉터 (garbage collector)에 의해 메모리에서 해제된다. 그러나 언제 해제될지는 예측할 수 없다.

  - 이처럼 Garbage Collector가 있는 언어를 Managed Language라고 한다.

---

### 6. 네이밍 규칙

- 변수의 이름을 지을 때에는 규칙이 있다.

  - 특수문자를 제외한 문자, 숫자, \_, $로 시작해야 한다는 것.

  - 카멜케이스와 파스칼케이스로 이름을 지어야 한다는 것.

```js
// camelCase
var firstName;

// PascalCase
var FirstName;

// 변수나 함수에선 카멜케이스를, 함수나 클래스에선 파스칼케이스를 사용한다.
```

---

## 5장. 표현식과 문

### 1. 리터럴 Literal

- Litera은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)이다.

- 종류는 정말 다양하다. 정수, 부동소수점, 2/8/16진수, 문자열, boolean, null, undefined, 객체, 배열, 함수, 정규표현식...

### 2. 표현식 (expression)

- 값으로 평가될 수 있다면 모두 표현문에 해당한다.

```js
// literal expression
10;
("hello");

// 식별자 표현식(선언이 이미 존재한다고 가정할 때)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수 / 메서드 호출 표현식 (선언이 이미 존재한다고 가정할 때)
square();
person.getName();
```

---

### 3. Semi Colon, 세미콜론

- 세미콜론은 문(statement)의 종료를 나타내기 때문에 문을 끝낼 때에는 세미콜론을 붙여야 하지만, if, for, 함수 등 {}를 사용하는 코드 블록에는 세미콜론을 붙이지 않는다. 이들은 문의 종료를 의미하는 자체 종결성 (self closing)을 갖기 때문.

- ASI : Automatic Semicolon Intersion

  - 개발자가 세미콜론을 붙이지 않더라도 자동으로 statement가 끝나는 것 같은 지점에 세미콜론을 붙여준다. 다만 이는 개발자의 의도와는 다르게 세미콜론이 붙여지는 경우가 있으므로, 일반적인 경우에서는 항상 세미콜론을 붙이는 것이 규칙이다.

---

### 4. 표현식인 문과 표현식이 아닌 문

- 표현식인 문 / 표현식이 아닌 문을 구분하는 가장 좋은 방법은 변수에 할당해 보는 것이다.

```js
var x;

x = 100;

// 첫 번째 코드인 변수 선언문은 표현식이 아닌 문이고
// 두 번째 코드인 할당문은 그 자체가 표현식이면서 문에 해당한다.

var foo = var x; // -> SyntaxError : Unexpected token var

var foo = x = 100;
console.log(foo); // -> 100
```

- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력한다. 이를 완료 값(completion value) 라고 한다.

- 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.

```js
// 표현식이 아닌 문
var foo = 10; // -> undefined
if (true) {
} // -> undefined

// 표현식인 문
var num = 10; // -> undefined

100 + num; // -> 110
num = 100; // -> 100
```
