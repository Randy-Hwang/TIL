# 2022. 06. 02 Today I Learned

## 자바스크립트 심화

> Truthy / Falsy

```js
const a = "";

if (a) {
  console.log("true");
} else {
  console.log("false");
}
// false
```

- true / false의 값을 넣지 않고 빈 문자열을 넣었는데도 false라는 값이 출력되었습니다.

```js
const a = "string";

if (a) {
  console.log("true");
} else {
  console.log("false");
}
// true
```

- 빈 문자열이 아닌 문자가 존재하는 문자열을 넣었을 때에는 true라고 인식합니다. 그 외에도 빈 배열 또한 true를 반환합니다.

자신만의 기준을 가지고 truthy, falsy를 나누어 boolean을 반환하게 됩니다.

> 단락 회로 평가

&&, ||, !, 이런 연산자들이 있습니다. 단락 회로 평가는 왼쪽에서부터 평가를 진행하는 특성을 이용한 평가 방식입니다.

대표적으로 Or 연산자의 경우 둘 중 하나만 true여도 true를 반환합니다. 따라서, 앞의 값이 true가 되어버리면 뒤의 값을 보지않고 평가를 종료합니다.

```js
const getName = (person) => {
  const name = person && person.name;
  return name || "객체가 아닙니다";
};

let duckgu = { name: "duckgu" };
console.log(getName(duckgu));
```

단락 회로 평가를 사용한 조건문입니다. `getName`이라는 함수 안의 첫 번째 코드에서 `person`이 객체라면 person.name을 변수에 저장하고, 객체가 아니라면 person 그 자체를 반환합니다. 즉, 밑의 리턴 부분에서 name이 truthy한 값인지 falsy한 값인지 검사하는 것입니다.

- 정상적으로 객체를 반환했다면 truthy한 값일테니 name을 리턴하고 바로 코드가 종료될테고, falsy한 값을 주었다면 뒤의 코드까지 실행할테니 "객체가 아닙니다" 라는 문구를 반환하게 되는겁니다.

---

> 비 구조화 할당 / 구조 분해 할당

```js
let arr = [1, 2, 3];

let [one, two, three] = arr;
console.log(one, two, three); // 1 2 3
```

각각의 변수를 배열의 인덱스 순서에 맞추어 할당하는 것을 말합니다.

```js
let a = 10;
let b = 20;

[a, b] = [b, a];
console.log(a, b); // 20 10
```

이렇게 값을 바꾸는 과정에서 비구조화 할당이 매우 유용하게 사용됩니다. 에어비앤비나 KTX 예매할 때, 카카오택시, 네비게이션 등 출발지와 도착지를 바꾸는 과정에서 충분히 활용가능한 코드인 것 같습니다.

```js
let object = {
  one: 1,
  two: 2,
  three: 3,
};

let { one: realOne, two: realTwo, three: realThree } = object;
console.log(realOne, realTwo, realThree); // 1 2 3
```

`object`에 이렇게 세 개의 키와 밸류값이 존재한다고 했을 때, 비 구조화 할당으로 밸류 값을 받을 수 있습니다.

각 밸류 값을 받을 때에는 키 값을 명시하여 받아야 하는데, 콜론을 사용한다면 본인이 설정한 변수명을 활용하여 밸류 값을 변수에 지정받을 수 있습니다.

---

> 동기, 비동기

자바스크립트는 싱글 스레드 작업방식을 가지고 있습니다. 자바스크립트는 코드가 작성된 순서대로 작업을 처리합니다.

이전 작업이 진행중일때는 다음 작업을 수행하지 않고 기다리고, 먼저 작성된 코드가 다 실행되고 나서야 다음 코드가 실행됩니다.

이를 동기 방식의 처리라고 합니다.

동기 처리 방식의 문제점은, 앞의 작업이 너무 오래 걸리기 시작하면 뒤의 작업들 또한 그 시간에 비례하여 처리속도가 늦어진다는 것을 의미합니다.

- 그렇다면 이 문제를 어떻게 해결할 수 있을까요? 스레드의 개수를 늘려버리면 가장 편한 결과이지만, 자바스크립트는 싱글 스레드로 운영되고 있습니다.

  - 비동기 방식으로 처리해야 하는데, 싱글 스레드이지만 작업 처리의 순서에 상관없이 동시에 모든 작업을 실행시켜버리는 방식입니다.

  - 자바스크립트는 기본적으로 비동기 처리방식을 가지고 있기때문에 `setTimeOut`과 같은 비동기 방식을 처리하지 못합니다. 따라서, 비동기 처리방식을 만나게 되면 그 부분을 Web APIs로 넘겨버리고 스레드는 다음 작업을 실행합니다. Web APIs로 간 코드는 멈추는 것이 아니라 그곳에서 실행되고, 자바스크립트는 다음 코드를 마음놓고 실행하게 됩니다.

  - 만약 처리가 다 끝나고 이제 실행되어야 할 차례라면 Web APIs에서 빠져나와 Callback Queue 라는 곳으로 해당 코드가 이동하게 됩니다. 콜백큐에 담겨진 코드는 이벤트 루프를 통해 다시금 콜스택(자바스크립트 스레드)로 옮겨질 수 있습니다.

  - 콜 스택으로 이동한다는 것은 코드가 실행된다는 것과 비슷한 의미입니다. `setTimeOut`으로 예를 들었으니 계속 예를 들자면, 이때껏 `setTimeOut`으로 인해 시간을 기다리다 이제 실행할 때가 되었다는 것입니다.

- promise, async, await을 사용하지 않으면 콜백지옥에 빠질 확률이 매우 높습니다.

> 여담이지만, 사실 저는 비동기 함수를 작성하면서도 "굳이 이거를 비동기로 적어야하나?" 싶은 순간들이 많았습니다... 아직 대형 프로젝트를 맡아보지 않아서 그런 것일까요?

비동기 작업은 세 가지 상태를 가질 수 있습니다. pending, fullfilled, rejected.

다만 이런 비동기 처리의 경우 강의를 듣는 것 보다는 실제로 코드를 작성하면서 경험해볼 필요가 있다고 느꼈습니다. 애초에 동기적인 처리 방식을 비동기로 바꾼다는걸 간단한 예제 코드로 보여주기 위해서 1초, 2초, 3초 기다렸다가 실행되는 코드들을 짜는 사람들이 많습니다.

근데 왠지 저는 그 예시가 와닿지도 않고 "굳이?" 싶은 생각만 계속 들었습니다. 아무래도 예제이다 보니 최대한 간단하게 보여주어야 하고, 그러다 보니 현실성이 부족한 것이 아닌가 생각했습니다.

- 아무래도 비동기 처리방식인 `async`와 `await`은 어떻게 작성하는지 배우기만 한 후에 코드를 직접 만져보며 사용법을 익혀야 할 것 같습니다.

---

> API fetch

API란 무엇인가요?

저는 그냥 특정 정보를 제공하는 웹페이지 주소라고만 생각했습니다. 다들 적어놓은 블로그 글들을 보면 'API에서 정보를 받아옵니다' / '정보를 받아오기 위해 API를 사용합니다' 라고 적으며 뒤에는 url이 적혀있었기 때문입니다.

API = Application Programming Interface. 응용 프로그램 프로그래밍 인터페이스

도대체 뭔 소린가요?

-
